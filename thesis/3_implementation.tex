\section{Implementation}

The algorithm was implemented using Python using the \textit{OpenCV} and
\textit{NumPy} libraries. OpenCV provided the different image processing methods
described in \ref{used} as well as other methods for reading, writing
and manipulating image files. NumPy which is part of the SciPy package is a
package for scientific numerical computing \cite{scipy}. Images in OpenCV are
represented as three-dimensional NumPy arrays. The first two dimensions of these
array encode the positions of pixels in the image, while the third dimension
encodes the three color values.

\subsection{Structure}

The processing and detection of the image was implemented in a function
\texttt{process\_image}. This function takes a 3-dimensional array representing
the image as an input and outputs a tuple. The first element of that tuple is
the actual output, a list of rectangles found in the image. Each rectangle is
represented by a \textit{Dictionary} with their respective position, dimensions
and color. The second element is a list of images, which represent different steps
of the algorithm and are artifacts meant for debugging and feedback.

Another function called \texttt{run\_pipeline} read a list of images from a
given input directory and fed them into \texttt{process\_image}. Each of the
debug images given were saved to disk in an output directory. The data from the
rectangles was encoded into \textit{JSON} and saved as well.

The \texttt{process\_image} first calls another function \texttt{preprocessing}
that executes the steps described in \ref{preprocessing}. The different processing
steps were also provided for debugging and adjustment of the parameters. By
running the program and looking at the result of the Thresholding the threshold
value $t = 110$ was determined to give reasonable results.
% TODO:
% Min length m?
% Distance d?
% How to choose N?

Then the result of \texttt{preprocessing(image)} is called by
\texttt{detect\_rectangles}. This function executes the steps described in
\ref{rectangles}. The result is a list of rectangles and their colors. As
well as images that show a visual representation of the rectangles next to
the input image. This can be used to validate the result of the algorithm.

Leaving out debugging steps, the \texttt{detect\_rectangles} function can be
boiled down to the following code:

\begin{lstlisting}
def detect_rectangles(preprocessed_img, original_img):
  (h1, v1) = detect_lines(preprocessed_img)
  (h2, v2) = reduce_lines(h1,v1)
  (h3, v3) = remove_lines_close_to_border(h2,v2)
  (h4, v4) = add_border_lines(h3,v3)
  (h5, v5) = connect_lines(h4,v4)
  (tl, bl, br, tr) = find_corners(h5,v5)
  rects = find_rectangles(tl, bl, tr))
  rects_with_color = find_colors_for_rects(rects, original_img)
  return rects_with_color
\end{lstlisting}

\subsection{Performance}

The performance of the algorithm was measured by timing the duration for each
image. The first implementation of the algorithm took about 1100 milliseconds per
iteration. By running timings on different parts of the processing, the
\texttt{detect\_lines} function was discovered as a bottle neck. It was
accountable for about 93 percent of the processing time.

This was the only place in the program were we iterated through all of the pixels
in the image using Python. All other operations were done using OpenCV or NumPy.
They also iterate through all of the pixel but using optimized C code.

To reduce the time of this step we decided to reimplement this function in a
compiled, more low-level language. We chose to use Rust using the \textit{rust-cpython}
library for bindings. Using the same algorithm implemented in Rust, the time of
this step was reduce from about 1020 to 40 milliseconds. The run time of the
program could be reduced by a factor of 13.

% - run from the command line `python main.py`
% - Test phase: Run through images
%
% - Wie haben Sie Ihr Konzept umgesetzt?
% - Wie ist Ihre Software strukturiert?
% - Was sind exemplarische Quelltextfragmente, die zeigen, wie Ihre Programm arbeitet?
%
% Challenges?
% Code: Pseudo/Python?
